start: bool
rules:
# boolean / propositional logic rules
- lhs: bool
  rhs:
    - bool
    - bool
  name: "and"
  function: |
    lambda p1 , p2 : p1 and p2
  weight: 1.0
- lhs: bool
  rhs:
    - bool
    - bool
  name: "or"
  function: |
    lambda p1 , p2 : p1 or p2
  weight: 1.0
- lhs: bool
  rhs:
    - bool
  name: "not"
  function: |
    lambda p : not p
  weight: 1.0
# set logic rules
- lhs: frozenset
  rhs:
    - frozenset
    - frozenset
  name: "union"
  function: |
    lambda s1, s2 : s1 | s2
  weight: 1.0
- lhs: frozenset
  rhs:
    - frozenset
    - frozenset
  name: "intersection"
  function: |
    lambda s1, s2 : s1 & s2
  weight: 1.0
- lhs: frozenset
  rhs:
    - frozenset
    - frozenset
  name: "difference"
  function: |
    lambda s1, s2 : s1 - s2
  weight: 1.0
- lhs: frozenset
  rhs:
    - int
    - frozenset
  name: "index"
  function: |
    lambda i, s: frozenset([sorted(s)[i]]) if i < len(s) else frozenset()
  weight: 1.0
- lhs: int
  rhs:
    - frozenset
  name: "cardinality"
  function: |
    lambda s: len(s)
  weight: 1.0
- lhs: bool
  rhs:
    - frozenset
    - frozenset
  name: "subset_eq"
  function: |
    lambda s1, s2: s1.issubset(s2)
  weight: 1.0
# integer logical rules
- lhs: bool
  rhs:
    - int
    - int
  name: "equals"
  function: |
    lambda i1, i2: i1 == i2
  weight: 1.0
- lhs: bool
  rhs:
    - int
    - int
  name: "greater_than"
  function: |
    lambda i1, i2: i1 > i2
  weight: 1.0
# primitive
- lhs: frozenset
  rhs: 
  name: "A"
  function: |
    lambda q: q.A
  weight: 10.0
- lhs: frozenset
  rhs: 
  name: "B"
  function: |
    lambda q: q.B
  weight: 10.0